<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[page]]></title>
    <url>%2F2019%2F06%2F25%2Fpage%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[c语言实现静态通讯录]]></title>
    <url>%2F2019%2F06%2F01%2Fc%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%9D%99%E6%80%81%E9%80%9A%E8%AE%AF%E5%BD%95%2F</url>
    <content type="text"><![CDATA[c语言实现静态通讯录功能包括：添加联系人删除联系人查询联系人修改联系人展示通讯录清空通讯录排序联系人代码如下contact.h文件#define _CRT_SECURE_NO_WARNINGS 1 #ifndef _TEST_H_ #define _TEST_H_ #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;assert.h&gt; #define NAME_SIZE 64 #define TEL_SIZE 15 #define ADDRE_SIZE 128 #define MAX_SIZE 5 typedef struct person { char name[NAME_SIZE]; char sex; unsigned char age; char telphone[TEL_SIZE]; char address[ADDRE_SIZE]; }person_t, *person_p, **person_pp; typedef struct contact { int size; person_t list[MAX_SIZE]; }contact_t,*contact_p,*contact_pp; void Menu(); void Init_Cont(contact_p cp); void Add_Person(contact_p cp); void Dele_Person(contact_p cp); void Search_Person(contact_p cp); void Mod_Person(contact_p cp); void Show_Person(contact_p cp); void Clear_Contact(contact_p cp); void Sort_Person(contact_p cp); #endif coantact.c文件#include&quot;test.h&quot; void Menu() { printf(&quot;**************************************\n&quot;); printf(&quot;***** 1.Add 2.Dele *****\n&quot;); printf(&quot;***** 3.Sear 4.Mod *****\n&quot;); printf(&quot;***** 5.Show 6.Cle *****\n&quot;); printf(&quot;***** 7.Sort 0.Exit *****\n&quot;); printf(&quot;**************************************\n&quot;); printf(&quot;Please Select :&quot;); } void Init_Cont(contact_p cp)//初始化 { assert(cp); memset(cp-&gt;list, 0, sizeof(person_t)*MAX_SIZE);//将空间初始化为0 cp-&gt;size = 0; } void Add_Person(contact_p cp)//添加联系人信息 { assert(cp!=NULL); if(cp-&gt;size == MAX_SIZE)//判断通讯录是否为满 { printf(&quot;Contact is full!!!\n&quot;); } printf(&quot;Please enter name:&quot;); scanf(&quot;%s&quot;,cp-&gt;list[cp-&gt;size].name); printf(&quot;Please enter sex:&quot;); scanf(&quot; %c&quot;,&amp;(cp-&gt;list[cp-&gt;size].sex)); printf(&quot;Please enter age:&quot;); scanf(&quot; %u&quot;,&amp;(cp-&gt;list[cp-&gt;size].age)); printf(&quot;Please enter telphone number:&quot;); scanf(&quot; %s&quot;,cp-&gt;list[cp-&gt;size].telphone); printf(&quot;Please enter adderss:&quot;); scanf(&quot; %s&quot;,cp-&gt;list[cp-&gt;size].address); (cp-&gt;size)++; } void Show_Person(contact_p cp)//显示通讯录 { assert(cp); int i = 0; if (cp-&gt;size == 0)//判断通讯录是否为空 { printf(&quot;Contact is empty!!!\n&quot;); } for (i = 0; i &lt; (cp-&gt;size); i++) { printf(&quot;%-2s|%-5c|%-9u|%-12s|%-17s\n&quot;, cp-&gt;list[i].name, cp-&gt;list[i].sex,\ cp-&gt;list[i].age, cp-&gt;list[i].telphone, cp-&gt;list[i].address); } } int find(contact_p cp, char *name)//按名查找联系人 { int i = 0; for (i = 0; i&lt;cp-&gt;size; i++) { if (strcmp(cp-&gt;list[i].name, name) == 0) return i; } return -1; } void Search_Person(contact_p cp)//按姓名查找联系人 { int ret = 0; char name[NAME_SIZE]; assert(cp); printf(&quot;Please enter name for search :&quot;); scanf(&quot;%s&quot;, name); ret = find(cp, name); if (ret == -1)//判断查找是否合法 { printf(&quot;Not find this people\n&quot;); } else { printf(&quot;%-2s|%-5c|%-9u|%-12s|%-17s\n&quot;, cp-&gt;list[ret].name, cp-&gt;list[ret].sex,\ cp-&gt;list[ret].age, cp-&gt;list[ret].telphone, cp-&gt;list[ret].address); } } void Dele_Person(contact_p cp)//按姓名删除联系人 { assert(cp); char name[NAME_SIZE]; int i = 0; int ret = 0; printf(&quot;Please entr name for delete :&quot;); scanf(&quot;%s&quot;, name); ret = find(cp, name); if (ret == -1)//判断查找是否合法 printf(&quot;Not find this people !!\n&quot;); else { for (i = ret; i &lt; cp-&gt;size; i++) { cp-&gt;list[i] = cp-&gt;list[i + 1]; } cp-&gt;size--; printf(&quot;delete success !!\n&quot;); } } void Mod_Person(contact_p cp) { char name[MAX_SIZE]; int ret = 0; printf(&quot;Please enter name for modify :&quot;); scanf(&quot;%s&quot;, name); ret = find(cp, name); if (ret == -1)//判断查找是否合法 { printf(&quot;Not find this people&quot;); } else { printf(&quot;Please enter name:&quot;); scanf(&quot;%s&quot;, cp-&gt;list[ret].name); printf(&quot;Please enter sex:&quot;); scanf(&quot; %c&quot;, &amp;(cp-&gt;list[ret].sex)); printf(&quot;Please enter age:&quot;); scanf(&quot; %u&quot;, &amp;(cp-&gt;list[ret].age)); printf(&quot;Please enter telphone number:&quot;); scanf(&quot; %s&quot;, cp-&gt;list[ret].telphone); printf(&quot;Please enter adderss:&quot;); scanf(&quot; %s&quot;, cp-&gt;list[ret].address); } } void Clear_Contact(contact_p cp)//清空通讯录 { cp-&gt;size = 0; } int person_cmp(const void *x, void *y)//姓名大小比较 { person_p _x = (person_p)x; person_p _y = (person_p)y; return strcmp(_x-&gt;name, _y-&gt;name); } void Sort_Person(contact_p cp)//按姓名排序 { qsort(cp-&gt;list, cp-&gt;size, sizeof(person_t), person_cmp);//利用qsort函数实现比较 printf(&quot;Sort success !!!\n&quot;); } main.c文件#include&quot;test.h&quot; int main() { int quit = 0; int select = 0; contact_t ct; Init_Cont(&amp;ct); while (!quit) { Menu(); scanf(&quot;%d&quot;, &amp;select); switch (select) { case 1: Add_Person(&amp;ct); break; case 2: Dele_Person(&amp;ct); break; case 3: Search_Person(&amp;ct); break; case 4: Mod_Person(&amp;ct); break; case 5: Show_Person(&amp;ct); break; case 6: Clear_Contact(&amp;ct); break; case 7: Sort_Person(&amp;ct); break; case 0: printf(&quot;Thank you for use!!\n&quot;); quit = 1; break; default: printf(&quot;select error!!! please select again&quot;); break; } } system(&quot;pause&quot;); return 0; }]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>通讯录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组与指针]]></title>
    <url>%2F2019%2F05%2F25%2F%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[指针与数组1. 一级指针一级指针是存放地址的变量。2. 二级指针二级指针是存放指针的变量。3. 指针和数组数组名可当做指针，在sizeof（arr）和&amp;arr的情况下，数组名代表整个数组的地址，其余情况下，数组名代表数组首元素的地址。列如：结果如下虽然arr与&amp;arr的结果相同，但arr代表首元素的大小，&amp;arr代表整个数组的大小。因为，指针+1代表加上其所指类型的大小。所以arr+1为0115FA34，&amp;arr+1为0115FA48，他们之间相差24（整个数组的大小）4. 指针数组指针数组是数组，其内部存放的元素为指针。当指针数组作为参数时，数组名降维成指向其内部元素类型的指针，即为二级指针。]]></content>
      <categories>
        <category>C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[文件操作]]></title>
    <url>%2F2019%2F05%2F25%2F%E6%96%87%E4%BB%B6%E5%87%BD%E6%95%B0%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[文件函数的操作fopen打开一个文件流函数原型：FILE* fopen(const char *path, const char *mode)； 参数：参数path是需要打开文件的文件名，通常把它叫做文件的路径，参数 mode 是打开文件的权限（只读、只写、读写等）。返回值：打开成功返回指向打开文件的指针，后序可以通过这个指针来访问该文件。打开失败则返回NULL。“r”（只读），为了输入数据，打开一个已经存在的文本文件出错“w”（只写），为了输出数据，打开一个文本文件，建立一个新的文件“a”（追加），向文本文件尾添加数据，出错“rb”（只读），为了输入数据，打开一个二进制文件，出错“wb”（只写），为了输出数据，打开一个二进制文件，建立一个新的文件“ab”（追加），向一个二进制文件尾添加数据，出错fcloseint fclose ( FILE * stream )； fwritesize_t fwrite(const void *buffer,size_t size,size_t count ,FILE *stream); 参数：参数buffer是想要写入到文件流里边去的内容。 参数size是将要写入元素的大小。参数count是将要写入元素的个数。参数stream是将要写入的地方。返回值：返回成功写入数据的字节数。fprintfint fprintf (FILE *stream,const char *format,...) 参数：参数stream是文件指针参数format格式化字符串 后边跟输出列表返回值：本次写入操作写到文件中的字节数。fprintf 与 printf 的区别在于，printf 是写入到标准输出（屏幕）上，而 fprintf 是写入到文件中fscanfint fsacnf (FILE *stream,const char *format,...) 参数：参数stream是文件指针参数format格式化字符串后边跟将要被赋值的变量返回值：本次成功获取数据的字节数。fscanf 与 scanf 的区别在于，scanf 是从标准输入（键盘）读取数据，而 fscanf 是从指定的文件中读取数据。fseek改变文件随机读写int fseek (FILE *stream, long int offset, int origin ); 参数：参数stream是文件指针，offset是偏移量，origin是指偏移方式。有如下三种值可选：SEEK_SET 从距文件开头offset 位移量为新的读写位置.SEEK_CUR 以目前的读写位置往后增加offset 个位移量.SEEK_END 将读写位置指向文件尾后再增加offset 个位移量返回值：调用成功返回0，失败返回-1，errno会存放错误代码。ftell返回文件指针相对于起始位置的偏移量long int ftell (FILE *stream ); rewind让文件指针的位置回到文件的起始位置void rewind (FILE *stream );]]></content>
      <categories>
        <category>C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自定义类型]]></title>
    <url>%2F2019%2F05%2F25%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%EF%BC%9A%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%8C%E6%9E%9A%E4%B8%BE%EF%BC%8C%E8%81%94%E5%90%88%2F</url>
    <content type="text"><![CDATA[自定义类型：结构体，枚举，联合1.结构体结构体是不同类型元素的集合，可以整体初始化，不能整体赋值。结构体声明struct tag{char a;int b;double c;}x;匿名结构体类型struct{char a;int b;double c;}结构体初始化struct tag x = {‘a’,10,5.00};嵌套类型结构体初始化struct a{char a;int b;}x;struct e{char f;struct e *x;}n1={‘a’,{‘b’,10}};结构体内存对齐问题下面这个二维数组的大小是60再看下面这个结构体可能我们会认为结构体大小为：1+4+8=13，然而结果并不是如此结果为16因为发生了内存对齐，产生内存对齐有两个主要原因：平台原因(移植原因)： 不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址 处取某些特定类型的数据，否则抛出硬件异常。性能原因： 数据结构(尤其是栈)应该尽可能地在自然边界上对齐。 原因在于，为了访问未对齐的内存，处理 器需要作两次内存访问；而对齐的内存访问仅需要一次访问。计算结构体大小第一个成员在与结构体变量偏移量为0的地址处。其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍。如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是 所有最大对齐数（含嵌套结构体的对齐数）的整数倍。所以sizeof(struct s4)=1+3+4+8=16再看下面这个结构体，内部嵌套了结构体我们知道struct s3的大小为8，对齐数为4，所以struct s4的大小为:1+3+4+8+8=24,并且24是最大对齐数 8 的倍数。####位段位段的声明和结构是类似的，有两个不同：1.位段的成员必须是 int、unsigned int 或signed int 。2.位段的成员名后边有一个冒号和一个数字。e.g位段跨平台问题int 位段被当成有符号数还是无符号数是不确定的。位段中最大位的数目不能确定。（16位机器最大16，32位机器最大32，写成27，在16位机器会出问 题。位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义。当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是舍弃剩余的 位还是利用，这是不确定的。枚举枚举顾名思义就是一一列举。把可能的取值一一列举。枚举的定义enum Sex{MALE,FEMALE,SECRET}；联合体联合也是一种特殊的自定义类型 这种类型定义的变量也包含一系列的成员，特征是这些成员公用同一块空间//联合类型的声明union Un{char c;int i;};//联合变量的定义union Un un;//计算连个变量的大小printf(“%d\n”, sizeof(un));]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>结构体</tag>
      </tags>
  </entry>
</search>
